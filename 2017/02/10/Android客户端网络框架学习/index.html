<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="作为实习生，在研究公司客户端代码的时候发现里面用了一个网络框架，之前自己做的玩具代码没有真正用过这类框架，所以专门研究了一下。
在浏览项目时最常见的用法就是通过构建一个FormRequest发起一个请求，like this：
123456789101112131415161718192021222324252627FormRequest.Builder builder=new FormReques">
<meta property="og:type" content="article">
<meta property="og:title" content="Android客户端网络框架学习">
<meta property="og:url" content="https://still-maos.github.io/2017/02/10/Android客户端网络框架学习/index.html">
<meta property="og:site_name" content="不忘初心">
<meta property="og:description" content="作为实习生，在研究公司客户端代码的时候发现里面用了一个网络框架，之前自己做的玩具代码没有真正用过这类框架，所以专门研究了一下。
在浏览项目时最常见的用法就是通过构建一个FormRequest发起一个请求，like this：
123456789101112131415161718192021222324252627FormRequest.Builder builder=new FormReques">
<meta property="og:image" content="http://ol76jdosj.bkt.clouddn.com/a.jpg">
<meta property="og:image" content="http://ol76jdosj.bkt.clouddn.com/okhttp.jpg">
<meta property="og:image" content="http://ol76jdosj.bkt.clouddn.com/interceptor2.jpg">
<meta property="og:image" content="http://ol76jdosj.bkt.clouddn.com/volley.jpg">
<meta property="og:image" content="http://ol76jdosj.bkt.clouddn.com/okvolley.jpg">
<meta property="og:updated_time" content="2017-02-15T12:45:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android客户端网络框架学习">
<meta name="twitter:description" content="作为实习生，在研究公司客户端代码的时候发现里面用了一个网络框架，之前自己做的玩具代码没有真正用过这类框架，所以专门研究了一下。
在浏览项目时最常见的用法就是通过构建一个FormRequest发起一个请求，like this：
123456789101112131415161718192021222324252627FormRequest.Builder builder=new FormReques">
<meta name="twitter:image" content="http://ol76jdosj.bkt.clouddn.com/a.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://still-maos.github.io/2017/02/10/Android客户端网络框架学习/"/>





  <title> Android客户端网络框架学习 | 不忘初心 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">不忘初心</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">少即是多</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Blog
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/works/index" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Work
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Resume
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://still-maos.github.io/2017/02/10/Android客户端网络框架学习/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Still Maos">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="不忘初心">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="不忘初心" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android客户端网络框架学习
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-10T20:39:36+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>作为实习生，在研究公司客户端代码的时候发现里面用了一个网络框架，之前自己做的玩具代码没有真正用过这类框架，所以专门研究了一下。</p>
<p>在浏览项目时最常见的用法就是通过构建一个FormRequest发起一个请求，like this：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">FormRequest.Builder builder=<span class="keyword">new</span> FormRequest.Builder();</div><div class="line">builder.setMethod(Request.Method.POST);</div><div class="line">builder.setUrl(requestHead + URL_NAME);</div><div class="line">builder.addExtraData();</div><div class="line">builder.addParam(<span class="string">"param1"</span>, <span class="string">"aaa"</span>);</div><div class="line">builder.addParam(<span class="string">"param2"</span>, <span class="string">"bbb"</span>);</div><div class="line">builder.addSuccessListener(<span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(response)) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject(response);</div><div class="line">        <span class="keyword">int</span> status = jsonObject.optInt(<span class="string">"status"</span>);</div><div class="line">        <span class="comment">// parse jsonObject...</span></div><div class="line">      &#125; <span class="keyword">catch</span> (JSONException e) &#123;</div><div class="line">        Log.e(<span class="string">"ResponseParseError"</span>, e.toString());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">builder.addFailureListener(<span class="keyword">new</span> Response.ErrorListener() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span> </span>&#123;</div><div class="line">    ToastCreater.showShortToast(<span class="string">"Error！"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">OkVolley.getInstance().addRequest(builder.build());</div></pre></td></tr></table></figure>
<p>使用起来非常的简洁舒适，先通过内部Builder初始化，然后加入到Volley的请求队列中去就行了。因此令我产生了一探究竟的想法，点进FormRequest去看，它的继承结构是这样：</p>
<p><img src="http://ol76jdosj.bkt.clouddn.com/a.jpg" alt="a"></p>
<p>嗯。。查看源码可以发现它们逐级封装了URL、请求方式、Header、Body、优先级、Builder等等。将Http请求这个东西逐步具体化。</p>
<p>学习框架前这我突然想到一个问题，我们为什么要使用网络框架？（想起了在学校时老师让我们用socket写请求的时候。。。）</p>
<p>学过Android开发的人都知道，在处理网络模块的时候需要考虑很多问题，比如说：</p>
<p>​    1.Android主线程不能进行网络请求，需要另开线程处理</p>
<p>​    2.异步请求</p>
<p>​    3.缓存处理</p>
<p>​    4.网络问题处理，像二次连接、SSL的握手失败问题，以及从网络错误状态中恢复等    </p>
<p>​    5.blabla…</p>
<p>如果没有网络框架，面对这些问题，我们就必须一次又一次自己处理，效率低下不说，还容易导致bug满天飞。而且一个封装良好的网络框架可以提供很好的使用体验，就像上面那样。</p>
<p>首先回忆一下自己之前常用的基础Android网络API，自然就是它们两个：</p>
<p>​    <strong>• HttpClient</strong>：</p>
<p>​    功能丰富，但API结构复杂，已失去维护，在5.0版本后被谷歌弃用</p>
<p>​    <strong>• HttpURLConnection</strong>：</p>
<p>​    包很小，速度快，谷歌愿意进一步提高性能，2.3之前存在bug</p>
<p>HttpClient是apache的一个开源库，被Google加入了SDK里，应该是一个封装的比较完善的库，提供了非常丰富的API，Bug数量很少。但也正因为其API数量太多，结构复杂，很难在不破坏其兼容性的情况下对它进行扩展和升级，Google已经弃用了它。而HttpURLConnection则是一个轻量级的、快速的HTTP请求封装，在2.2之前存在一个著名的bug，就是连接池失效的问题。HttpURLConnection没有支持HttpClient那么多的功能，但是也正因为这样，Google认为提升它的性能和功能更加容易，因此推荐使用。这两个兄弟的故事告诉我们一个道理：一时的优势也可能变成劣势，劣势也能变成优势，祸兮福之所倚，福兮祸之所伏。。。（扯远了）</p>
<p>但是我们的项目并没有用这俩，而是使用了一个新的东东：okHttp。</p>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>我的理解是OkHttp是一个现代、高效的类似HttpUrlConnection的东西。它具有很多优点，下面列出一些我比较能理解的：</p>
<p>1.支持SPDY黑科技，可以合并多个到同一个主机的请求</p>
<p>2.socket自动选择最好路线，并支持自动重连</p>
<p>3.拥有自动维护的socket连接池，减少握手次数</p>
<p>4.使用<a href="https://goo.gl/F7rG1V" target="_blank" rel="external">Okio</a>来大大简化数据的访问与存储</p>
<p>5.可以自动处理常见的网络问题</p>
<p>6.如果服务器配置了多个IP地址，当IP连接失败的时候，OkHttp会自动尝试下一个IP</p>
<p>7.同时支持同步或异步请求</p>
<p>8.从Android4.4开始HttpURLConnection的底层实现采用的是okHttp</p>
<h3 id="引用Okhttp"><a href="#引用Okhttp" class="headerlink" title="引用Okhttp"></a>引用Okhttp</h3><p>Android Studio中可以在Gradle中进行如下配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">compile <span class="string">'com.squareup.okio:okio:1.11.0'</span></div><div class="line">compile <span class="string">'com.squareup.okhttp3:okhttp:3.5.0'</span></div></pre></td></tr></table></figure>
<h3 id="探究OkHttp"><a href="#探究OkHttp" class="headerlink" title="探究OkHttp"></a>探究OkHttp</h3><p>OkHttp最核心的类应该就是一个OkHttpClient，它把okhttp包内封装的Request对象构造成Call对象。Call是HTTP请求的又一个封装，那为啥还要封装呢？我们看看OkHttpClient的newCall方法里做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * Prepares the &#123;<span class="doctag">@code</span> request&#125; to be executed at some point in the future.</div><div class="line">   */</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RealCall(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket) &#123;</div><div class="line">  <span class="keyword">this</span>.client = client;</div><div class="line">  <span class="keyword">this</span>.originalRequest = originalRequest;</div><div class="line">  <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">  <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造了一个Call的具体实现RealCall，这个东西拿到了OkHttpClient和原始的Request对象，然后做什么呢？我们打开Request的源码，可以看到它只封装了Head、Body、Method、Url、是否Https等基本的请求属性，而在RealCall里面则定义了execute、enqueue、cancel等方法和interceptors的处理。下面看看RealCall的这几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>enqueue就是定义了一个回调借口，封装一个AsyncCall，交给了Dispatcher去调度。AsyncCall是RealCall里的内部类，这是一个真正的线程，它里面有个execute方法，长这个样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Response response = getResponseWithInterceptorChain();</div><div class="line">    <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">      signalledCallback = <span class="keyword">true</span>;</div><div class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      signalledCallback = <span class="keyword">true</span>;</div><div class="line">      responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    <span class="keyword">if</span> (signalledCallback) &#123;</div><div class="line">      <span class="comment">// Do not signal the callback twice!</span></div><div class="line">      Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到主要就是执行了 Response response = getResponseWithInterceptorChain()这一条，然后就是回调了。这个AsyncCall会被dispatcher发配到具体线程执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</div><div class="line">    Response result = getResponseWithInterceptorChain();</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个execute和上一个enqueue中AsyncCall的execute很像，同样把工作交给了getResponseWithInterceptorChain去做。可以看到execute中显然是一个同步单线程执行的请求，它自己返回拿到的结果（OkHttp封装的Response）。可见enqueue和execute中都用了这个方法去真正执行Request，那么在getResponseWithInterceptorChain()中究竟做了什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  interceptors.addAll(client.interceptors());</div><div class="line">  interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">    interceptors.addAll(client.networkInterceptors());</div><div class="line">  &#125;</div><div class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它把我们自己设置的interceptors，加上内置的interceptors，串成串。然后造了一个Chain对象，把拦截器和原始Request放进去，还预设了一个index为0，那这个东西有什么用呢？这个就要研究一下拦截器的执行过程了，在下节继续探究。经过上面的分析，OkHttp执行的一个大体过程就比较清晰了，如下图所示。</p>
<p><img src="http://ol76jdosj.bkt.clouddn.com/okhttp.jpg" alt="okhttp"></p>
<h3 id="OkHttp拦截器"><a href="#OkHttp拦截器" class="headerlink" title="OkHttp拦截器"></a>OkHttp拦截器</h3><p>看RealInterceptorChain的构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span></span></div><div class="line">    HttpCodec httpCodec, Connection connection, <span class="keyword">int</span> index, Request request) &#123;</div><div class="line">  <span class="keyword">this</span>.interceptors = interceptors;</div><div class="line">  <span class="keyword">this</span>.connection = connection;</div><div class="line">  <span class="keyword">this</span>.streamAllocation = streamAllocation;</div><div class="line">  <span class="keyword">this</span>.httpCodec = httpCodec;</div><div class="line">  <span class="keyword">this</span>.index = index;</div><div class="line">  <span class="keyword">this</span>.request = request;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从它里面拿到的东西看它似乎要搞一个大事情。而且这里面connection、streamAllocation都是什么鬼？我们先不管它，继续看里面的代码，前面代码中在生成Chain之后就调用了它的proceed方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></div><div class="line">    Connection connection) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line"></div><div class="line">  calls++;</div><div class="line"></div><div class="line">  <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !sameConnection(request.url())) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</div><div class="line">        + <span class="string">" must retain the same host and port"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</div><div class="line">        + <span class="string">" must call proceed() exactly once"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">  Interceptor interceptor = interceptors.get(index);</div><div class="line">  Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">  <span class="comment">// Confirm that the next interceptor made its required call to chain.proceed().</span></div><div class="line">  <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</div><div class="line">        + <span class="string">" must call proceed() exactly once"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Confirm that the intercepted response isn't null.</span></div><div class="line">  <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法中对httpCodec和请求url做了判断，然后开始执行第一个interceptor。这时重新构造了一个新的Chain对象，然后传给了interceptor，进入它的intercept方法。那么我们看看一个interceptor的实现长什么样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Interceptor.Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = chain.request();</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">    logger.info(String.format(<span class="string">"Sending request %s on %s%n%s"</span>,</div><div class="line">        request.url(), chain.connection(), request.headers()));</div><div class="line"></div><div class="line">    Response response = chain.proceed(request);</div><div class="line"></div><div class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</div><div class="line">    logger.info(String.format(<span class="string">"Received response for %s in %.1fms%n%s"</span>,</div><div class="line">        response.request().url(), (t2 - t1) / <span class="number">1e6</span>d, response.headers()));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个自定义拦截器中有个重要的地方，必须通过chain.proceed(request)获取Response，也就是说它会再调用一次上面的方法，获取下一个interceptor，继续执行。为什么要这么做呢？因为拦截器里的工作是分拦截前和拦截后两部分进行的，如下图：</p>
<p><img src="http://ol76jdosj.bkt.clouddn.com/interceptor2.jpg" alt="interceptor"></p>
<p>它以这样的方式分层运行，因此上面的代码可以保证我们一个拦截器不需要重写两个回调方法，而chain.proceed(request)将我们的intercept方法截成了两部分。因此，可以想到，在RealCall中最后加入的那个拦截器中，存在真正执行网络请求的代码，点进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** This is the last interceptor in the chain. It makes a network call to the server. */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallServerInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> forWebSocket;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CallServerInterceptor</span><span class="params">(<span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();</div><div class="line">    StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();</div><div class="line">    Request request = chain.request();</div><div class="line"></div><div class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class="line">    httpCodec.writeRequestHeaders(request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</div><div class="line">      Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</div><div class="line">      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</div><div class="line">      request.body().writeTo(bufferedRequestBody);</div><div class="line">      bufferedRequestBody.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    httpCodec.finishRequest();</div><div class="line"></div><div class="line">    Response response = httpCodec.readResponseHeaders()</div><div class="line">        .request(request)</div><div class="line">        .handshake(streamAllocation.connection().handshake())</div><div class="line">        .sentRequestAtMillis(sentRequestMillis)</div><div class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">        .build();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> code = response.code();</div><div class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</div><div class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(Util.EMPTY_RESPONSE)</div><div class="line">          .build();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(httpCodec.openResponseBody(response))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</div><div class="line">        || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</div><div class="line">      streamAllocation.noNewStreams();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</div><div class="line">          <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>果然在这。这里面真正执行了请求，构建了Response。从它之后就开始逐级往回走，执行其他拦截器的拦截后操作。</p>
<p>拦截器的设计思想其实就是一种面向切面编程的体现，一个interceptor就是一个切面，而切入点就在OkHttpClient中。不同于Spring框架的动态代理实现方案，拦截器直接使用addInterceptor把切面切入到了切入点中，而在这个过程中OkHttpClient的源代码不需要有任何的变化。即通过将作用于某一些目标Request上的通用操作提取，实现了在不修改源码的前提下，在程序运行时动态地将代码作用于这一批Request上，使得我们的Request不需要预先写死很多也许不会用到的操作，真正实现了高效的可扩展性。</p>
<h2 id="OkVolley"><a href="#OkVolley" class="headerlink" title="OkVolley"></a>OkVolley</h2><p><strong>——“即使你要单独使用OkHttp，还是会再包一层的，这样就等价于Volley之流的框架，只是封装的好与坏而已。”</strong></p>
<p>我看到在我们的客户端中并没有直接使用OkHttp，因为OkHttp本质上还是HttpURLConnection那一级别的东西，它只处理了Http请求这一过程所需要解决的问题，而作为一个客户端网络框架来直接用的话还是不够方便的。而在我们的项目中，使用了Volley。</p>
<p>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。</p>
<p>Volley的主要特点：</p>
<p>(1). <strong>扩展性强</strong>。Volley 中大多是基于接口的设计，可配置性强。</p>
<p>(2). Volley特别适合<strong>数据量小，通信频繁</strong>的网络操作。</p>
<p>(3).默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现。</p>
<p>(4). 提供简便的图片加载工具。</p>
<h4 id="Volley的组成"><a href="#Volley的组成" class="headerlink" title="Volley的组成"></a>Volley的组成</h4><p><strong>Volley：</strong></p>
<p>这是Volley 对开发者提供的主要API，我们在这里面创建请求队列。</p>
<p><strong>Request：</strong></p>
<p>各种具体Request继承自Request抽象基类。我们可以基于它创建具体的Request类，如ImageRequest、JsonRequest等。</p>
<p><strong>RequestQueue：</strong></p>
<p>我们创建的请求实例被加入到这个请求队列中，它里面包含1个CacheDispatcher和若干个（好像默认是4个）NetworkDispatcher，通过start方法启动它们。</p>
<p><strong>CacheDispatcher：</strong></p>
<p>这是一个线程，用于调度处理走缓存的请求。</p>
<p><strong>NetworkDispatcher：</strong></p>
<p>这也是一个线程，用于调度处理走网络的请求。</p>
<p><strong>ResponseDelivery：</strong></p>
<p>返回结果分发接口。</p>
<p><strong>HttpStack：</strong></p>
<p>这个类非常重要，在它的performRequest方法中真正处理 Http 请求，返回一个古老的HttpResponse请求结果。</p>
<p><strong>Network：</strong></p>
<p>调用HttpStack处理请求，将HttpStack返回的HttpResponse封装成可被ResponseDelivery处理的NetworkResponse。</p>
<p><strong>Cache：</strong></p>
<p>在sdcard中缓存请求结果。</p>
<p>所以整个Volley框架的执行流程应该就是下图这个样子：</p>
<p><img src="http://ol76jdosj.bkt.clouddn.com/volley.jpg" alt="http://ol76jdosj.bkt.clouddn.com/volley.jpg"></p>
<h3 id="OkVolley的封装"><a href="#OkVolley的封装" class="headerlink" title="OkVolley的封装"></a>OkVolley的封装</h3><p>最后最厉害的地方来了，我们前面介绍的OkHttp怎么和Volley结合呢？答案很简单，就是这张图：</p>
<p><img src="http://ol76jdosj.bkt.clouddn.com/okvolley.jpg" alt="http://ol76jdosj.bkt.clouddn.com/okvolley.jpg"></p>
<p>只需要两步：自己重新创建一个继承HttpStack的OkHttpStack，在其PerformRequest中使用OkHttpClient进行请求执行与结果解析。然后在Volley中使用这个HttpStack创建RequestQueue，就可以使用了！</p>
<p>只需要简单的替换，就可以将Volley配置成基于OkHttp的OkVolley。这个封装充分体现了Volley的面向接口编程，而不是面向实现编程的设计原则，实现了强大的可扩展性。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/17/android-event-dispatch/" rel="prev" title="Android事件分发过程总结">
                Android事件分发过程总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Still Maos" />
          <p class="site-author-name" itemprop="name">Still Maos</p>
          <p class="site-description motion-element" itemprop="description">二逼程序员, 绝命画师</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#OkHttp"><span class="nav-number">1.</span> <span class="nav-text">OkHttp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引用Okhttp"><span class="nav-number">1.1.</span> <span class="nav-text">引用Okhttp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#探究OkHttp"><span class="nav-number">1.2.</span> <span class="nav-text">探究OkHttp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OkHttp拦截器"><span class="nav-number">1.3.</span> <span class="nav-text">OkHttp拦截器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OkVolley"><span class="nav-number">2.</span> <span class="nav-text">OkVolley</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Volley的组成"><span class="nav-number">2.0.1.</span> <span class="nav-text">Volley的组成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OkVolley的封装"><span class="nav-number">2.1.</span> <span class="nav-text">OkVolley的封装</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Still Maos</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


</body>
</html>
